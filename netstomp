#!/usr/bin/env ruby
#
# Emulate varying network failure modes
#
# @see man(8) tc
# @see man(8) tc-netem

require 'optparse'
require 'benchmark'

class QDisc
  def initialize(qdisc, device, parent, handle, params)
    @qdisc  = qdisc
    @device = device
    @parent = parent
    @handle = handle
    @params = params
  end

  def add
    "tc qdisc add #{identifier} #{@qdisc} #{@params}"
  end

  def delete
    "tc qdisc delete #{identifier}"
  end

  def run(opts = {}, &block)
    execute(add, opts[:noop])
    block.call
  ensure
    execute(delete, opts[:noop])
  end

  private

  def execute(cmd, noop)
    #log(cmd)
    if !noop
      %x{#{cmd}}
    end
  end

  def log(str)
    puts "execute: #{str}"
  end

  def identifier
    id = "dev #{@device} #{@parent}"
    id << " handle #{@handle}" if @handle
    id
  end
end

class Netem < QDisc
  def initialize(device, parent, handle, params)
    super("netem", device, parent, handle, params)
  end

  def self.corrupt(device, parent, handle, pct)
    new(device, parent, handle, "corrupt #{pct}%")
  end
end

def corrupt(specifier, command, min, max)
  min.upto(max) do |i|
    puts "Running with corruption level #{i}%"
    time = Benchmark.realtime do
      Netem.corrupt(*specifier, i).run(:noop => false) do
        puts "Executing command '#{command}'"
        system(command)
      end
    end
    puts "Command ran in %.2f seconds" % time
  end
end

# @return [OptionParser]
def parser(options)
  options[:parent] = "root"
  options[:handle] = nil

  op = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} --device DEV --command CMD"

    opts.on("-d", "--device DEV", "The device to stomp on") do |value|
      options[:device] = value
    end

    opts.on("-c", "--corrupt RANGE", "Execute the command with corruption rates between min,max") do |value|
      options[:corrupt] = value.split(',')
    end

    opts.on("-h", "--help", "Print this help") do
      puts opts
      exit
    end
  end

  op
end

def parse(argv)
  options = {}

  op = parser(options)
  command = op.parse(argv).join(" ")

  if options[:device].nil?
    puts "Device is nil"
    puts op
    exit(1)
  end

  [options, command]
end

def run(argv)
  options, command = parse(argv)

  specifier = [options[:device], "root", nil]

  if options[:corrupt]
    min, max = options[:corrupt]
    corrupt(specifier, command, min, max)
  end
end

run(ARGV)
